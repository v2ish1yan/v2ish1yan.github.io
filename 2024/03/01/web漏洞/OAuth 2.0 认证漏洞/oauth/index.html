<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Oauth2" />
    <meta name="hexo-theme-A4" content="v1.8.8" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Hexo</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
            
<link rel="stylesheet" href="/css/waline.css">

        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.1.1"></head>
    
    <style>
        :root {
            --waline-theme-color: #000000; 
            --waline-color: #000000; 
            --waline-border-color: #000000; 
            --waline-white: #000000; 
            --waline-bgcolor-light: #ffffff;  
        }
        body {
            color: #000000;
            background: #e4e4e4;
        }
        .post-md code {
            background: #212425;
            color: white; 
        }
        .post-md pre, .post-md .highlight {
            background: #212425;
            color: white; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #000000;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #000000;
        }
        .year-font-color {
            color: #000000 !important;
        }
        .wl-card span.wl-nick {
            color: #000000; 
        }
        .wl-card .wl-badge {
            border: 1px solid #000000;
            color: #000000; 
        }
        .wl-btn {
            border: 1px solid #000000; 
            color:  #000000;  
        }
        .wl-btn.primary {
            color: #ffffff; 
        }
        .wl-header label {
            color: #000000;
        }
        a {
            color: rgb(239, 112, 96);
        }

        .post-md a {
            color: rgb(239, 112, 96);
        }

        .nav li a {
            color: rgb(239, 112, 96);
        }

        .archive-main a:link {
            color: rgb(239, 112, 96);
        }
        .archive-main a:visited {
            color: rgb(239, 112, 96); 
        }

        .archive li span {
            color: #000000;
        }

        .post-main-title {
            color: #000000;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #000000;
        }

        [data-waline] p {
            color: #000000;
        }
        [data-waline] a {
            color: #000000;
        } 
        .wl-sort li.active {
            color: #000000;
        }

        .wl-card .wl-meta>span {
            background: #ffffff;
        }

        .paper {
            background: #e4e4e4;
        }

        .index-main {
            background: #ffffff;
        }

        .paper-main {
            background: #ffffff;
        }

        .wl-panel {
            background: #ffffff;
        }

        .archive li:nth-child(odd) {
            background: #ffffff;
            ;
        }

        .archive li:nth-child(even) {
            background: #ffffff;
        }

        .post-md table tr:nth-child(odd) td {
            background: #ffffff;
        }

        .post-md table tr:nth-child(even) td {
            background: #ffffff;
        }

    
        .progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, rgb(239, 112, 96), rgb(239, 112, 96)); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, rgb(239, 112, 96), rgb(239, 112, 96)); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #000000; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: rgb(239, 112, 96);
            border-left-color: rgb(239, 112, 96);
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #000000;
        }
    </style>

    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Hexo</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/friends/">友链</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Oauth2
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-OAuth%EF%BC%9F"><span class="post-toc-text">什么是 OAuth？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AC%94%E8%AE%B0"><span class="post-toc-text">笔记</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#OAuth-2-0-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="post-toc-text">OAuth 2.0 如何工作？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OAuth%E8%AE%A4%E8%AF%81"><span class="post-toc-text">OAuth认证</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#OAuth%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="post-toc-text">OAuth身份验证漏洞是如何产生的？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AF%86%E5%88%AB-OAuth-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="post-toc-text">识别 OAuth 身份验证</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BE%A6%E5%AF%9F"><span class="post-toc-text">侦察</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%A9%E7%94%A8-OAuth-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%BC%8F%E6%B4%9E"><span class="post-toc-text">利用 OAuth 身份验证漏洞</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OAuth-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E"><span class="post-toc-text">OAuth 客户端应用程序中的漏洞</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E6%96%BD%E4%B8%8D%E5%BD%93"><span class="post-toc-text">隐式授权类型的实施不当</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84-CSRF-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E3%80%82"><span class="post-toc-text">有缺陷的 CSRF 保护机制。</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%84%E9%9C%B2%E6%8E%88%E6%9D%83%E7%A0%81%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C"><span class="post-toc-text">泄露授权码和访问令牌</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84redirect-uri%E9%AA%8C%E8%AF%81"><span class="post-toc-text">有缺陷的redirect_uri验证</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E9%A1%B5%E9%9D%A2%E7%AA%83%E5%8F%96%E4%BB%A3%E7%A0%81%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C"><span class="post-toc-text">通过代理页面窃取代码和访问令牌</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%8C%83%E5%9B%B4%E9%AA%8C%E8%AF%81%E6%9C%89%E7%BC%BA%E9%99%B7"><span class="post-toc-text">范围验证有缺陷</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%8C%83%E5%9B%B4%E5%8D%87%E7%BA%A7%EF%BC%9A%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B%E4%B8%BA%E6%8E%88%E6%9D%83%E7%A0%81"><span class="post-toc-text">范围升级：授权类型为授权码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%8C%83%E5%9B%B4%E5%8D%87%E7%BA%A7%EF%BC%9A%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B%E4%B8%BA%E7%AE%80%E5%8C%96%E6%8E%88%E6%9D%83"><span class="post-toc-text">范围升级：授权类型为简化授权</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%AA%E7%BB%8F%E9%AA%8C%E8%AF%81%E7%9A%84%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C"><span class="post-toc-text">未经验证的用户注册</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-OpenID-Connect-%E6%89%A9%E5%B1%95-OAuth"><span class="post-toc-text">使用 OpenID Connect 扩展 OAuth</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFOpenID-Connect%EF%BC%9F"><span class="post-toc-text">什么是OpenID Connect？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OpenID-Connect%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="post-toc-text">OpenID Connect如何工作？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#OpenID-Connect-%E8%A7%92%E8%89%B2"><span class="post-toc-text">OpenID Connect 角色</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#OpenID-Connect-%E5%A3%B0%E6%98%8E%E5%92%8C%E8%8C%83%E5%9B%B4"><span class="post-toc-text">OpenID Connect 声明和范围</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ID-token"><span class="post-toc-text">ID token</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%86%E5%88%AB-OpenID-Connect"><span class="post-toc-text">识别 OpenID Connect</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OpenID-Connect-%E6%BC%8F%E6%B4%9E"><span class="post-toc-text">OpenID Connect 漏洞</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%8A%A8%E6%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E5%86%8C"><span class="post-toc-text">不受保护的动态客户端注册</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%81%E8%AE%B8%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83%E8%AF%B7%E6%B1%82"><span class="post-toc-text">允许通过引用进行授权请求</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="什么是-OAuth？"><a href="#什么是-OAuth？" class="headerlink" title="什么是 OAuth？"></a>什么是 OAuth？</h2><p>OAuth 是一种常用的授权框架，它使网站和 Web 应用程序能够请求对另一个应用程序上的用户帐户进行有限访问。至关重要的是，OAuth 允许用户授予此访问权限，而无需向请求应用程序公开其登录凭据。这意味着用户可以<strong>微调</strong>他们想要共享的数据，而不必将其帐户的完全控制权移交给第三方。</p>
<p>基本 OAuth 流程广泛用于集成需要从用户帐户访问某些数据的第三方功能。例如，应用程序可能使用 OAuth 请求访问您的电子邮件联系人列表，以便它可以建议与之联系的人员。然而，同样的机制也用于提供第三方身份验证服务，允许用户使用他们在不同网站上拥有的帐户登录。</p>
<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><blockquote>
<p>尽管 OAuth 2.0 是当前标准，但一些网站仍然使用旧版本 1a。OAuth 2.0 是从头开始编写的，而不是直接从 OAuth 1.0 开发的。结果，两者非常不同。请注意，这些材料中的术语“OAuth”专指 OAuth 2.0。</p>
</blockquote>
<h2 id="OAuth-2-0-如何工作？"><a href="#OAuth-2-0-如何工作？" class="headerlink" title="OAuth 2.0 如何工作？"></a>OAuth 2.0 如何工作？</h2><p>OAuth 2.0 最初是作为一种在应用程序之间共享特定数据访问权限的方式而开发的。它的工作原理是定义三个不同方（即客户端应用程序、资源所有者和 OAuth 服务提供商）之间的一系列交互。</p>
<ul>
<li><strong>客户端应用程序</strong>- 想要访问用户数据的网站或 Web 应用程序。</li>
<li><strong>资源所有者</strong>- 客户端应用程序想要访问其数据的用户。</li>
<li><strong>OAuth 服务提供商</strong>- 控制用户数据及其访问权限的网站或应用程序。它们通过提供用于与授权服务器和资源服务器交互的 API 来支持 OAuth。</li>
</ul>
<p>OAuth 2.0 最初是作为一种在应用程序之间共享特定数据访问权限的方式而开发的。它的工作原理是定义三个不同方（即客户端应用程序、资源所有者和 OAuth 服务提供商）之间的一系列交互。</p>
<ul>
<li><strong>客户端应用程序</strong>- 想要访问用户数据的网站或 Web 应用程序。</li>
<li><strong>资源所有者</strong>- 客户端应用程序想要访问其数据的用户。</li>
<li><strong>OAuth 服务提供商</strong>- 控制用户数据及其访问权限的网站或应用程序。它们通过提供用于与授权服务器和资源服务器交互的 API 来支持 OAuth。</li>
</ul>
<p>实际的 OAuth 流程可以通过多种不同的方式来实现。这些被称为 OAuth“流程”或“授权类型”。在本主题中，我们将重点关注“授权代码”和“隐式”授权类型，因为这些类型是迄今为止最常见的。一般来说，这两种资助类型都涉及以下阶段：</p>
<ol>
<li>客户端应用程序请求访问用户数据的子集，指定他们想要使用的授权类型以及他们想要的访问类型。</li>
<li>系统会提示用户登录 OAuth 服务并明确同意所请求的访问权限。</li>
<li>客户端应用程序收到一个唯一的访问令牌，证明它们拥有用户访问所请求数据的权限。具体发生的方式因资助类型的不同而有很大差异。</li>
<li>客户端应用程序使用此访问令牌进行 API 调用，从资源服务器获取相关数据。</li>
</ol>
<h3 id="OAuth认证"><a href="#OAuth认证" class="headerlink" title="OAuth认证"></a>OAuth认证</h3><p>尽管最初并非用于此目的，但 OAuth 已经演变成了一种认证用户的手段。</p>
<p>例如，您可能熟悉许多网站提供使用您现有的社交媒体账户登录而不必注册该网站的选项。</p>
<p>每当您看到此选项时，很有可能它是基于 OAuth 2.0 构建的。</p>
<p>对于OAuth认证机制，基本的OAuth流程基本上保持不变；</p>
<p>主要的区别在于客户端应用程序如何使用接收到的数据。</p>
<p>从最终用户的角度来看，OAuth认证的结果在很大程度上类似于基于SAML的单点登录（SSO）。在这些材料中，我们将专门关注这种<strong>SSO使用情况</strong>下的漏洞。</p>
<p>OAuth身份验证通常实现如下:</p>
<ol>
<li>用户选择使用其社交媒体帐户登录的选项。然后，客户端应用程序使用社交媒体网站的 OAuth 服务来请求访问可用于识别用户身份的某些数据。例如，这可能是在其帐户中注册的电子邮件地址。</li>
<li>收到访问令牌后，客户端应用程序从资源服务器（通常是从专用端点<code>/userinfo</code>）请求此数据。</li>
<li>一旦收到数据，客户端应用程序就会使用它代替用户名来登录用户。通常使用从授权服务器收到的访问令牌来代替传统密码。</li>
</ol>
<h2 id="OAuth身份验证漏洞是如何产生的？"><a href="#OAuth身份验证漏洞是如何产生的？" class="headerlink" title="OAuth身份验证漏洞是如何产生的？"></a>OAuth身份验证漏洞是如何产生的？</h2><p>OAuth 身份验证漏洞的出现部分是因为 OAuth 规范的设计相对<strong>模糊且灵活</strong>。</p>
<p>尽管每种授权类型的基本功能都需要一些强制性组件，但绝大多数实现都是完全可选的。这包括保护用户数据安全所需的许多配置设置。简而言之，不良做法有很多机会潜入。</p>
<p>OAuth 的其他关键问题之一是普遍缺乏内置安全功能。</p>
<p>安全性几乎完全依赖于开发人员使用正确的配置选项组合并在顶部实施自己的附加安全措施，例如强大的输入验证。正如您可能已经了解到的那样，需要了解的内容有很多，如果您对 OAuth 没有经验，那么很容易出错。</p>
<p>根据授权类型，高度敏感的数据也会通过浏览器发送，这为攻击者提供了各种拦截数据的机会。</p>
<h2 id="识别-OAuth-身份验证"><a href="#识别-OAuth-身份验证" class="headerlink" title="识别 OAuth 身份验证"></a>识别 OAuth 身份验证</h2><p>识别应用程序何时使用 OAuth 身份验证相对简单。如果您看到使用您的帐户从其他网站登录的选项，则强烈表明正在使用 OAuth。</p>
<p>识别 OAuth 身份验证的最可靠方法是通过 Burp 代理您的流量，并在您使用此登录选项时检查相应的 HTTP 消息。无论使用哪种 OAuth 授权类型，流程的第一个请求总会是许多专门用于 OAuth 的查询参数的端点 -<code>/authorization</code></p>
<p>特别要注意<code>client_id</code>、<code>redirect_uri</code>和<code>response_type</code>参数。例如，授权请求通常如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /authorization?client_id=12345&amp;redirect_uri=https://client-app.com/callback&amp;response_type=token&amp;scope=openid%20profile&amp;state=ae13d489bd00e3c24 HTTP/1.1</span><br><span class="line">Host: oauth-authorization-server.com</span><br></pre></td></tr></table></figure>

<h2 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h2><p>对正在使用的 OAuth 服务进行一些基本的侦察可以为您在识别漏洞方面指明正确的方向。</p>
<p>不用说，您应该研究构成 OAuth 流程的各种 HTTP 交互</p>
<p>如果使用外部 OAuth 服务，您应该能够从授权请求发送到的主机名识别特定的提供商。</p>
<p>由于这些服务提供公共 API，因此通常会有详细的文档可以告诉您各种有用的信息，例如端点的确切名称以及正在使用的配置选项。</p>
<p>一旦您知道授权服务器的主机名，您应该始终尝试<code>GET</code>向以下标准端点发送请求：</p>
<ul>
<li><code>/.well-known/oauth-authorization-server</code></li>
<li><code>/.well-known/openid-configuration</code></li>
</ul>
<p>这些通常会返回一个包含关键信息的 JSON 配置文件，例如可能支持的其他功能的详细信息。有时，这会提示您有关文档中可能未提及的更广泛的攻击面和支持的功能。</p>
<h2 id="利用-OAuth-身份验证漏洞"><a href="#利用-OAuth-身份验证漏洞" class="headerlink" title="利用 OAuth 身份验证漏洞"></a>利用 OAuth 身份验证漏洞</h2><p>客户端应用程序的 OAuth 实现以及 OAuth 服务本身的配置中可能会出现漏洞</p>
<h3 id="OAuth-客户端应用程序中的漏洞"><a href="#OAuth-客户端应用程序中的漏洞" class="headerlink" title="OAuth 客户端应用程序中的漏洞"></a>OAuth 客户端应用程序中的漏洞</h3><p>客户端应用程序通常会使用信誉良好、久经沙场的 OAuth 服务，该服务可以很好地防御众所周知的漏洞。然而，他们自己的实施方式可能不太安全。</p>
<p>正如我们已经提到的，OAuth 规范的定义相对宽松。对于客户端应用程序的实现来说尤其如此。OAuth 流程中有很多移动部分，每种授权类型都有许多可选参数和配置设置，这意味着错误配置的范围很大。</p>
<h4 id="隐式授权类型的实施不当"><a href="#隐式授权类型的实施不当" class="headerlink" title="隐式授权类型的实施不当"></a>隐式授权类型的实施不当</h4><p>由于通过浏览器发送访问令牌带来的危险，隐式授权类型主要建议用于<strong>单页面</strong>应用程序。但是，由于其相对简单，它也经常用于经典的客户端-服务器Web应用程序中。</p>
<p>在这个流程中，访问令牌通过用户的浏览器作为 URL 片段从 OAuth 服务发送到客户端应用程序。然后客户端应用程序使用 JavaScript 访问令牌。问题在于，如果应用程序希望在用户关闭页面后保持会话，它需要将当前用户数据（通常是用户 ID 和访问令牌）存储在某个地方。</p>
<p>为了解决这个问题，客户端应用程序通常会在POST请求中提交这些数据，然后分配一个会话cookie给用户，有效地将其登录。</p>
<p>这个请求大致相当于作为经典基于密码的登录的一部分发送的表单提交请求。然而，在这种情况下，服务器<strong>没有任何密钥或密码与提交的数据进行比较</strong>，这意味着它是被隐式信任的。</p>
<p>在隐式流程中，这个POST请求通过浏览器暴露给攻击者。因此，如果客户端应用程序没有正确检查访问令牌是否与请求中的其他数据匹配，则此行为可能导致严重漏洞。在这种情况下，攻击者可以简单地更改发送到服务器的参数以冒充任何用户。</p>
<h4 id="有缺陷的-CSRF-保护机制。"><a href="#有缺陷的-CSRF-保护机制。" class="headerlink" title="有缺陷的 CSRF 保护机制。"></a>有缺陷的 CSRF 保护机制。</h4><p>尽管 OAuth 流程的许多组件是可选的，但除非有重要原因不使用它们，否则强烈建议使用其中一些。其中一个示例是<code>state</code>参数。</p>
<p>理想情况下，该<code>state</code>参数应包含一个不可猜测的值，例如首次启动 OAuth 流程时与用户会话相关的内容的哈希值。然后，该值作为客户端应用程序的 CSRF 令牌的形式在客户端应用程序和 OAuth 服务之间来回传递。</p>
<p>因此，如果您注意到授权请求没有发送参数<code>state</code>，那么从攻击者的角度来看，这非常有趣。这可能意味着他们可以在欺骗用户浏览器完成 OAuth 流程之前自行启动 OAuth 流程，类似于传统的<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/csrf">CSRF 攻击</a>。根据客户端应用程序使用 OAuth 的方式，这可能会产生严重后果。</p>
<p>考虑一个网站，允许用户使用传统的基于密码的机制或使用OAuth将其帐户链接到社交媒体配置文件来登录。在这种情况下，如果应用程序未能使用<code>state</code>参数，则攻击者可能会通过<strong>将其绑定到自己的社交媒体帐户</strong>来劫持受害用户在客户端应用程序上的帐户。</p>
<blockquote>
<p>请注意，如果网站仅允许用户通过OAuth登录，则状态参数可能不那么关键。然而，不使用状态参数仍然可能会导致攻击者构造登录CSRF攻击，从而诱使用户登录到攻击者的帐户。</p>
</blockquote>
<h3 id="泄露授权码和访问令牌"><a href="#泄露授权码和访问令牌" class="headerlink" title="泄露授权码和访问令牌"></a>泄露授权码和访问令牌</h3><p>也许最臭名昭著的基于OAuth的漏洞是，当OAuth服务本身的配置使得攻击者能够窃取与其他用户账户关联的授权代码或访问令牌。</p>
<p>通过窃取有效的代码或令牌，攻击者可能能够访问受害者的数据。最终，这可能完全破坏他们的账户——攻击者可能会在注册了该OAuth服务的任何客户端应用程序上以受害者用户身份登录。</p>
<p>通过redirect_uri劫持来获取token和code</p>
<p>根据授权类型，通过受害者的浏览器发送代码或令牌到授权请求中redirect_uri参数指定的的<code>/callback</code>端点。</p>
<p>如果OAuth服务未能正确验证<code>redirect_uri</code>参数指定的URI，则攻击者可能能够构造类似CSRF的攻击，欺骗受害者的浏览器发起OAuth流程，将代码或令牌发送到攻击者控制的redirect_uri。</p>
<p>在授权码流程中，攻击者可以在其被使用之前窃取受害者的代码。然后，他们可以将此代码发送到客户端应用程序的合法<code>/callback</code>端点（原始<code>redirect_uri</code>参数指定的uri）以访问用户的帐户。</p>
<p>在这种情况下，攻击者甚至不需要知道客户端密钥或生成的访问令牌。只要受害者与OAuth服务有一个有效的会话，客户端应用程序就会在登录受害者的帐户之前代表攻击者完成代码&#x2F;令牌交换。</p>
<p>请注意，使用状态或一次性保护并不能完全防止这些攻击，因为攻击者可以从自己的浏览器中生成新值。</p>
<p>更安全的授权服务器在接受client发送的code时也需要发送一个redirect_uri参数。<br>服务器可以检查这个参数是否与初始授权请求中收到的参数匹配，如果不匹配，则拒绝交换。<br>由于这是通过安全的后端通道进行的服务器对服务器请求，攻击者无法控制这个第二个redirect_uri参数。</p>
<h4 id="有缺陷的redirect-uri验证"><a href="#有缺陷的redirect-uri验证" class="headerlink" title="有缺陷的redirect_uri验证"></a>有缺陷的redirect_uri验证</h4><p>由于先前实验中出现的攻击类型，最佳实践是在注册 OAuth 服务时，客户端应用程序提供其真实回调 URI 的白名单。这样，当 OAuth 服务接收到新请求时，它可以根据此白名单验证 redirect_uri 参数。在这种情况下，提供外部 URI 可能会导致错误。但是，仍然可能有方法绕过此验证。</p>
<p>在审核 OAuth 流程时，您应该尝试使用 redirect_uri 参数进行实验，以了解它是如何被验证的。例如：</p>
<ul>
<li><p>一些实现只检查字符串是否以正确的字符序列（即批准的域）开头，从而允许一系列子目录。您应该尝试删除或添加任意路径、查询参数和片段，看看可以在不触发错误的情况下更改哪些内容。</p>
</li>
<li><p>如果您可以向默认的redirect_uri参数附加额外的值，您可能能够利用OAuth服务的不同组件对URI解析之间的差异。例如，您可以尝试以下技术：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://default-host.com &amp;@foo.evil-user.net#@bar.evil-user.net/</span><br></pre></td></tr></table></figure>

<p>就像绕ssrf的防御一样</p>
<p>如果您不熟悉这些技术，我们建议您阅读有关如何<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf#circumventing-common-ssrf-defenses">规避常见 SSRF 防御</a>和<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/cors#errors-parsing-origin-headers">CORS</a>的内容</p>
</li>
<li><p>您偶尔可能会遇到服务器端参数污染（HPP）漏洞。为了以防万一，您应该尝试提交重复的<code>redirect_uri</code>参数，如下所示：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://oauth-authorization-server.com/?client_id=123&amp;redirect_uri=client-app.com/callback&amp;redirect_uri=evil-user.net</span><br></pre></td></tr></table></figure>

<ul>
<li>有些服务器也会对本地主机URI进行特殊处理，因为它们经常在开发过程中使用。在某些情况下，任何以localhost开头的重定向URI可能会在生产环境中被意外允许。这可能会允许您通过注册诸如localhost.evil-user.net之类的域名来绕过验证。</li>
</ul>
<p>重要的是要注意，您不应该将测试限制在孤立地探测redirect_uri参数上。<br>在实际应用中，您经常需要尝试对多个参数进行不同组合的更改。<br>有时更改一个参数可能会影响其他参数的验证。例如，将response_mode从<code>query</code>更改为<code>fragment</code>有时可以完全改变redirect_uri的解析，从而允许您提交本来会被阻止的URI。</p>
<p>同样，如果您注意到支持web_message响应模式，这通常允许更广泛的子域名在redirect_uri中使用。</p>
<h4 id="通过代理页面窃取代码和访问令牌"><a href="#通过代理页面窃取代码和访问令牌" class="headerlink" title="通过代理页面窃取代码和访问令牌"></a>通过代理页面窃取代码和访问令牌</h4><p>针对更强大的目标，您可能会发现无论您尝试什么，都无法成功提交外部域作为<code>redirect_uri</code>. 然而，这并不意味着是时候放弃了。</p>
<p>到这个阶段，你应该对哪些 URI 部分可以篡改有相对好的了解。<br>现在的关键是利用这个知识来尝试访问客户端应用程序内更广泛的攻击面。换句话说，试着弄清楚你是否可以更改 redirect_uri 参数来指向白名单域上的任何其他页面。</p>
<p>尝试找到可以成功访问不同子域或路径的方法。例如，默认 URI 通常位于 OAuth 特定路径上，例如<code>/oauth/callback</code>，它不太可能有任何有趣的子目录。但是，您可以使用<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/file-path-traversal">目录遍历</a>技巧来提供域上的任意路径。像这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://client-app.com/oauth/callback/../../example/path</span><br></pre></td></tr></table></figure>

<p>可能在后端被解释为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://client-app.com/example/path</span><br></pre></td></tr></table></figure>

<p>一旦您确定可以将哪些其他页面设置为重定向 URI，您应该对它们进行审核，以寻找可能用于泄露代码或令牌的其他漏洞。<br>对于授权码流程，您需要找到一个可以让您访问查询参数的漏洞，而对于简化授权类型，您需要提取 URL 片段。</p>
<p>其中最有用的漏洞之一是开放重定向。您可以将其用作代理，将受害者以及他们的代码或令牌转发到攻击者控制的域，您可以在其中托管任何恶意脚本。</p>
<p>请注意，对于隐式授权类型，窃取访问令牌不仅可以让您登录到客户端应用程序上的受害者帐户。由于整个隐式流程都是通过浏览器进行的，您还可以使用令牌向OAuth服务的资源服务器发出自己的API调用。这可能使您能够获取敏感用户数据，这些数据在客户端应用程序的Web UI中无法正常访问。</p>
<p>除了开放式重定向之外，您还应该寻找任何其他漏洞，以允许您提取代码或令牌并将其发送到外部域。一些很好的例子包括：</p>
<ul>
<li><strong>处理查询参数和 URL 片段的危险 JavaScript</strong><br>例如，不安全的网络消息脚本非常适合此类攻击。在某些情况下，您可能需要识别一个更长的小工具链，以便在最终将令牌泄漏到外部域之前，通过一系列脚本传递令牌。</li>
<li><strong><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/cross-site-scripting">XSS</a>漏洞</strong><br>尽管 XSS 攻击本身可能会产生巨大的影响，但攻击者能够访问用户会话的时间通常很短，因为用户会关闭选项卡或导航离开。由于 <code>HTTPOnly </code>属性通常用于会话 cookie，攻击者通常也无法使用 XSS 直接访问它们。但是，通过窃取 OAuth 代码或令牌，攻击者可以在自己的浏览器中访问用户的帐户。这使他们有更多时间探索用户的数据并执行有害操作，从而显着增加了 XSS 漏洞的严重程度。</li>
<li><strong>HTML 注入漏洞</strong><br>在无法注入 JavaScript 的情况下（例如，由于<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/cross-site-scripting/content-security-policy">CSP</a>限制或严格过滤），您仍然可以使用简单的 HTML 注入来窃取授权代码。如果您可以将<code>redirect_uri</code>参数指向可以注入自己的 HTML 内容的页面，则可能可以通过标头<code>Referer</code>泄漏来泄露code。例如，考虑以下<code>img</code>元素：<code>&lt;img src=&quot;evil-user.net&quot;&gt;</code>。当尝试获取此图像时，某些浏览器（例如 Firefox）将在<code>Referer</code>请求标头中发送完整的 URL，包括查询字符串。</li>
</ul>
<h3 id="范围验证有缺陷"><a href="#范围验证有缺陷" class="headerlink" title="范围验证有缺陷"></a>范围验证有缺陷</h3><p>在任何OAuth流程中，用户必须根据授权请求中定义的范围批准所请求的访问。生成的令牌允许客户端应用程序仅访问用户批准的范围。但在某些情况下，由于OAuth服务的缺陷验证，攻击者可能会将访问令牌（无论是被盗还是使用恶意客户端应用程序获得的）升级为具有额外权限的令牌。执行此操作的过程取决于授权类型。</p>
<h4 id="范围升级：授权类型为授权码"><a href="#范围升级：授权类型为授权码" class="headerlink" title="范围升级：授权类型为授权码"></a>范围升级：授权类型为授权码</h4><p>使用授权码授权类型，用户的数据通过安全的服务器对服务器通信请求和发送，第三方攻击者通常无法直接操纵。</p>
<p>然而，通过向OAuth服务注册<strong>自己</strong>的客户端应用程序，仍然有可能实现相同的结果。<br>例如，假设攻击者的恶意客户端应用程序最初使用<code>openid email</code>范围请求访问用户的电子邮件地址。在用户批准此请求后，恶意客户端应用程序将接收一个授权码。</p>
<p>由于攻击者控制他们的客户端应用程序，他们可以向请求token的数据包中添加另一个<code>scope</code>参数，其中包含附加的<code>profile</code>范围。</p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /token</span><br><span class="line">Host: oauth-authorization-server.com</span><br><span class="line">…</span><br><span class="line">client_id=12345&amp;client_secret=SECRET&amp;redirect_uri=https://client-app.com/callback&amp;grant_type=authorization_code&amp;code=a1b2c3d4e5f6g7h8&amp;scope=openid%20 email%20profile</span><br></pre></td></tr></table></figure>

<p>如果服务器没有根据初始授权请求的范围对其进行验证，有时会使用新的范围生成访问令牌并将其发送给攻击者的客户端应用程序：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;z0y9x8w7v6u5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">3600</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openid email profile&quot;</span><span class="punctuation">,</span></span><br><span class="line">    …</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>攻击者可以使用他们的应用程序进行必要的 API 调用来访问用户的个人资料数据。</p>
<h4 id="范围升级：授权类型为简化授权"><a href="#范围升级：授权类型为简化授权" class="headerlink" title="范围升级：授权类型为简化授权"></a>范围升级：授权类型为简化授权</h4><p>对于隐式授权类型，访问令牌通过浏览器发送，这意味着攻击者可以窃取与无辜客户端应用程序相关联的令牌并直接使用它们。</p>
<p>一旦他们窃取了访问令牌，他们可以通过手动添加新的<code>scope</code>参数来向OAuth服务的<code>/userinfo</code>端点发送正常的基于浏览器的请求。</p>
<p>理想情况下，OAuth 服务应该验证此<code>scope</code>的值与生成令牌时使用的<code>scope</code>的值是否相同，但并非总是如此。只要调整后的权限不超过先前授予此客户端应用程序的访问级别，攻击者就可能访问其他数据，而无需进一步获得用户的批准。</p>
<h3 id="未经验证的用户注册"><a href="#未经验证的用户注册" class="headerlink" title="未经验证的用户注册"></a>未经验证的用户注册</h3><p>通过 OAuth 对用户进行身份验证时，<strong>客户端应用程序</strong>会假定 OAuth 提供者存储的信息是正确的。这可能是一个危险的假设。</p>
<p>一些提供OAuth服务的网站允许用户注册账户时不验证所有详细信息，包括有时候不验证他们的电子邮件地址。</p>
<p>攻击者可以利用这一点，使用与目标用户相同的详细信息（如已知的电子邮件地址）在OAuth提供者那里注册账户。</p>
<p>客户端应用程序可能会允许攻击者通过此欺诈账户在OAuth提供者处以受害者身份登录。</p>
<p>目标用户在客户端注册了账户，而在第三方（即oauth服务提供者）没有注册账户的情况下，如果客户端应用程序不会验证从oauth认证的用户是否绑定了当前客户端应用程序的账户，那么就可以通过在oauth处创建一个和客户端应用程序上目标账户拥有一样邮箱的账户，然后通过oauth登录，来在客户端应用程序登录目标账户</p>
<h2 id="使用-OpenID-Connect-扩展-OAuth"><a href="#使用-OpenID-Connect-扩展-OAuth" class="headerlink" title="使用 OpenID Connect 扩展 OAuth"></a>使用 OpenID Connect 扩展 OAuth</h2><p>当用于身份验证时，OAuth 通常会使用 OpenID Connect 层进行扩展，该层提供了一些与识别和验证用户相关的附加功能。</p>
<h3 id="什么是OpenID-Connect？"><a href="#什么是OpenID-Connect？" class="headerlink" title="什么是OpenID Connect？"></a>什么是OpenID Connect？</h3><p>OpenID Connect 扩展了 OAuth 协议，以提供位于基本 OAuth 实现之上的专用身份和身份验证层。它添加了一些简单的功能，可以更好地支持 OAuth 的身份验证用例。</p>
<p>OAuth 最初在设计时并未考虑身份验证;它旨在成为在应用程序之间委派特定资源授权的一种方式。但是，许多网站开始自定义 OAuth 以用作身份验证机制。</p>
<p>为了实现这一点，他们通常请求对一些基本用户数据的读取访问权限，如果他们被授予此访问权限，则假定用户在 OAuth 提供程序方面对自己进行身份验证。</p>
<p>这些普通的OAuth身份验证机制远非理想。首先，客户端应用程序无法知道何时、何地或如何对用户进行身份验证。</p>
<p>由于这些实现中的每一个都是某种自定义解决方法，因此也没有为此目的请求用户数据的标准方法。</p>
<p>若要正确支持 OAuth，客户端应用程序必须为每个提供程序配置单独的 OAuth 机制，每个提供程序具有不同的终结点、唯一的作用域集等。</p>
<p>OpenID Connect通过添加标准化的、与身份相关的功能来解决了很多这些问题，使通过OAuth的身份验证以更可靠和统一的方式工作。</p>
<h3 id="OpenID-Connect如何工作？"><a href="#OpenID-Connect如何工作？" class="headerlink" title="OpenID Connect如何工作？"></a><strong>OpenID Connect如何工作？</strong></h3><p>OpenID 将像插件一样完整地连接到正常的 OAuth 流中。从客户端应用程序的角度来看，主要区别在于，对于所有提供程序，还有一组额外的标准化作用域<code>scope</code>，以及一个额外的响应类型：<code>id_token</code></p>
<h4 id="OpenID-Connect-角色"><a href="#OpenID-Connect-角色" class="headerlink" title="OpenID Connect 角色"></a>OpenID Connect 角色</h4><p>OpenID Connect 的角色与标准 OAuth 的角色基本相同。主要区别在于规范使用的术语略有不同</p>
<ul>
<li><p><strong>Relying party</strong>- 请求对用户进行身份验证的应用程序。这是 OAuth 客户端应用程序的同义词</p>
</li>
<li><p><strong>End user</strong> - 正在进行身份验证的用户。这是 OAuth 资源所有者的同义词</p>
</li>
<li><p><strong>OpenID provider</strong>- 配置为支持 OpenID 连接的 OAuth 服务</p>
</li>
</ul>
<h4 id="OpenID-Connect-声明和范围"><a href="#OpenID-Connect-声明和范围" class="headerlink" title="OpenID Connect 声明和范围"></a><strong>OpenID Connect 声明和范围</strong></h4><p>术语“claims”是指表示有关资源服务器上的用户的信息的键值对。例如<code>&quot;family_name&quot;:&quot;Montoya&quot;</code></p>
<p>在基本OAuth中，每个提供程序的作用域都是唯一的。与其不同的是，所有OpenID Connect服务都使用相同的范围集</p>
<p>为了使用 OpenID Connect，客户端应用程序必须在授权请求中指定范围。然后，它们可以包括一个或多个其他标准作用域：</p>
<ul>
<li><code>profile</code></li>
<li><code>email</code></li>
<li><code>address</code></li>
<li><code>phone</code></li>
</ul>
<p>每个作用域对应于对用户声明的子集的读取访问权限，这些声明在OpenID规范中定义。例如，请求 <code>openid profile </code>作用域将授予客户端应用程序读取访问一系列与用户身份有关的声明，例如 family_name、given_name、birth_date 等等。</p>
<h4 id="ID-token"><a href="#ID-token" class="headerlink" title="ID token"></a>ID token</h4><p>OpenID Connect 新增了一个<code>id_token</code>响应类型</p>
<p>这将返回使用 JSON Web 签名 （JWS） 签名的 JSON Web 令牌 （JWT）。</p>
<p>JWT 有效负载包含基于<strong>最初请求</strong>的范围的声明列表。</p>
<p>它还包含有关 OAuth 服务上次对用户进行身份验证的方式和时间的信息。客户端应用程序可以使用它来确定用户是否已通过充分身份验证。</p>
<p>使用<code>id_token</code>的主要好处是减少了需要在客户端应用程序和 OAuth 服务之间发送的请求数，这可以提供更好的整体性能。</p>
<p>在用户对自己进行身份验证后，包含此数据的 ID 令牌将立即发送到客户端应用程序，而不必获取访问令牌，然后单独请求用户数据。</p>
<p>与基本 OAuth 中发生的那样简单地依赖受信任通道不同，ID 令牌中传输的数据的完整性基于 JWT 加密签名。因此，使用 ID 令牌可能有助于防止某些中间人攻击。但是，鉴于用于签名验证的<strong>加密密钥</strong>通过同一网络通道（通常公开在 <code>/.well-known/jwks.json</code>）传输，一些攻击仍然是可能的。</p>
<p>请注意，OAuth 支持多种响应类型，因此客户端应用程序发送同时具有基本 OAuth 响应类型和 OpenID Connect 响应类型的授权请求是完全可以接受的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response_type=id_token token </span><br><span class="line">response_type=id_token code</span><br></pre></td></tr></table></figure>

<p>在这种情况下，ID 令牌和代码或访问令牌将同时发送到客户端应用程序</p>
<h3 id="识别-OpenID-Connect"><a href="#识别-OpenID-Connect" class="headerlink" title="识别 OpenID Connect"></a>识别 OpenID Connect</h3><p>如果客户端应用程序正在使用 OpenID 连接，则从授权请求中应该可以明显看出这一点。最万无一失的检查方法是检查<code>scope</code>参数中是否有<code>openid</code></p>
<p>即使登录过程最初看起来没有使用 OpenID Connect，仍然值得检查 OAuth 服务是否支持它。您可以简单地尝试添加<code>openid</code>范围或将响应类型更改为<code>id_token</code>，并观察这是否会导致错误。</p>
<p>与基本的OAuth一样，查看OAuth提供程序的文档以查看是否有有关其OpenID Connect支持的任何有用信息也是一个好主意。您还可以从标准端点<code>/.well-known/openid-configuration</code>访问配置文件。</p>
<h3 id="OpenID-Connect-漏洞"><a href="#OpenID-Connect-漏洞" class="headerlink" title="OpenID Connect 漏洞"></a>OpenID Connect 漏洞</h3><p>OpenID Connect的规范比基本OAuth的规范严格得多，这意味着具有明显漏洞的古怪实现的可能性通常较小。也就是说，由于它只是位于 OAuth 之上的一层，客户端应用程序或 OAuth 服务可能仍然容易受到我们之前看到的一些基于 OAuth 的攻击</p>
<h4 id="不受保护的动态客户端注册"><a href="#不受保护的动态客户端注册" class="headerlink" title="不受保护的动态客户端注册"></a><strong>不受保护的动态客户端注册</strong></h4><p>OpenID 规范概述了允许客户端应用程序向 OpenID 提供程序注册的标准化方法。如果支持动态客户端注册，则客户端应用程序可以通过向专用端点<code>/registration</code>发送<code>POST</code>请求来注册自身。</p>
<p>此终结点的名称通常在配置文件和文档中提供。</p>
<p>在请求正文中，客户端应用程序以 JSON 格式提交有关自身的关键信息。例如，通常需要包含一系列列入白名单的重定向 URI。它还可以提交一系列其他信息，例如要公开的端点的名称、应用程序的名称等。</p>
<p>典型的注册请求可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST /openid/register HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept: application/json</span><br><span class="line">Host: oauth-authorization-server.com</span><br><span class="line">Authorization: Bearer ab12cd34ef56gh89</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;application_type&quot;: &quot;web&quot;,</span><br><span class="line">    &quot;redirect_uris&quot;: [</span><br><span class="line">        &quot;https://client-app.com/callback&quot;,</span><br><span class="line">        &quot;https://client-app.com/callback2&quot;</span><br><span class="line">        ],</span><br><span class="line">    &quot;client_name&quot;: &quot;My Application&quot;,</span><br><span class="line">    &quot;logo_uri&quot;: &quot;https://client-app.com/logo.png&quot;,</span><br><span class="line">    &quot;token_endpoint_auth_method&quot;: &quot;client_secret_basic&quot;,</span><br><span class="line">    &quot;jwks_uri&quot;: &quot;https://client-app.com/my_public_keys.jwks&quot;,</span><br><span class="line">    &quot;userinfo_encrypted_response_alg&quot;: &quot;RSA1_5&quot;,</span><br><span class="line">    &quot;userinfo_encrypted_response_enc&quot;: &quot;A128CBC-HS256&quot;,</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OpenID 提供程序应要求客户端应用程序对自身进行身份验证。在上面的示例中，他们使用的是HTTP头中的Authorization进行的身份验证</p>
<p>但是，某些提供程序将允许动态客户端注册，而<strong>无需任何身份验证</strong>，这使攻击者能够注册自己的恶意客户端应用程序。这可能会产生各种后果，具体取决于如何使用这些攻击者可控制属性的值。</p>
<p>其中一些属性可以作为 URI 提供。如果 OpenID 提供程序访问其中任何一个，则可能会导致二阶 SSRF 漏洞，除非采取额外的安全措施。</p>
<p>比如说<code>logo_uri</code></p>
<h4 id="允许通过引用进行授权请求"><a href="#允许通过引用进行授权请求" class="headerlink" title="允许通过引用进行授权请求"></a><strong>允许通过引用进行授权请求</strong></h4><p>到目前为止，我们已经看过了通过查询字符串提交授权请求所需参数的标准方式，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/auth?client_id=r39qmmzdtfrcbu5h0eb1f&amp;redirect_uri=https://0a560045039dc84c809cdf89007900dc.web-security-academy.net/oauth-callback&amp;response_type=code&amp;scope=openid%20profile%20email</span><br></pre></td></tr></table></figure>

<p> 一些 OpenID 提供者提供了将这些参数作为 JSON Web Token（JWT）传递的选项<code>（Pushed Authorization Requests）</code>。</p>
<p>即一个请求对象，请求参数将作为声明添加到请求对象中。根据前面的 URL 编码查询字符串示例，请求对象将如下所示。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://idsvr.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;client-one&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;response_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;code&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;redirect_uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://oauth.tools/callback/code&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openid address secret_scope&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后将他们编码为jwt后，在请求授权的参数中，添加上<code>request</code>参数，来使用这个请求对象</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://idsvr.example.com/oauth/v2/oauth-authorize?</span><br><span class="line">&amp;client_id=client-one</span><br><span class="line">&amp;response_type=code</span><br><span class="line">&amp;scope=openid</span><br><span class="line">&amp;request=eyJhbGciOiJSUzUxMiJ9.eyJyZXNwb25zZV90eXBlIjoi...</span><br></pre></td></tr></table></figure>

<p>如果支持此功能，还可以发送一个指向包含其余 OAuth 参数及其值的 JSON Web Token 的单个<code>request_uri</code>参数。根据 OAuth 服务的配置，此  参数是另一个潜在的 SSRF 向量。也就是引用</p>
<p>当请求对象由于许多声明而非常大时，按引用选项很有用。对授权请求的引用可以由客户端和授权服务器都信任的第三方服务处理。这里的<code>request_uri</code>是用来引用一个jwt的值的，访问他，获得一个jwt值</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://idsvr.example.com/oauth/v2/oauth-authorize?</span><br><span class="line">&amp;client_id=client-one</span><br><span class="line">&amp;response_type=code</span><br><span class="line">&amp;scope=openid</span><br><span class="line">&amp;request_uri=https://example.com/request.jwt#MjZhNTY2NTVlNDgzNDE5ODAxMjZkYzRhMWM2NmFiYjU1ZWVkMzBjOTM5MzJiM2VjYjliY2ZkNGIyMmJiZjAwZA==</span><br></pre></td></tr></table></figure>

<p>您还可以使用此功能绕过这些参数值的验证。某些服务器可能会有效地验证授权请求中的查询字符串，但可能无法将相同的验证用于于 JWT 中的参数，包括<code>redirect_uri</code>。所以可以用来绕过</p>
<p>要检查是否支持此选项，您应该在配置文件和文档中查找该选项。或者，您可以尝试添加参数以查看它是否有效。您会发现某些服务器支持此功能，即使它们没有在其文档中明确提及此功能。</p>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-03-01</span>
            
                <span>该篇文章被 John Doe</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Oauth2/'>
                            Oauth2
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/web%E6%BC%8F%E6%B4%9E/'>
                            web漏洞
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        
    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
         
    </div>
    
        

    <div id="waline"></div>
    <script type="module"  >
        import { init } from 'https://npm.elemecdn.com/hexo-theme-a4@latest/source/js/waline.mjs'; 
        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://a4-talk.vercel.app',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
                search: false, // 禁止表情包搜索
                reaction: false, // 对文章打分
                pageview: false, // 浏览量统计
                comment: false, // 评论数统计

                locale: {
                    placeholder: '欢迎评论', 
                    sofa: ''
                },
            });
            
        }
        window.addEventListener('DOMContentLoaded', loadWaline);
    </script>



    
    
    
    </div>


     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊面朝大海，春暖花开🌸</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


    <!--暗黑模式-->
    <script src="/js/darkmode-js.min.js"></script>
    <script>
        function addDarkmodeWidget() {
        const options = {
            bottom: '53px', // default: '32px'
            right: 'unset', // default: '32px'
            left: '42px', // default: 'unset'
            time: '0.3s', // default: '0.3s'
            mixColor: '#fff', // default: '#fff'
            backgroundColor: ' #e4e4e4  ',  // default: '#fff'
            buttonColorDark: '#100f2c',  // default: '#100f2c'
            buttonColorLight: '#fff', // default: '#fff'
            saveInCookies: true, // default: true,
            label: '🌓', // default: ''
            autoMatchOsTheme: true // default: true
        }
    
        const darkmode = new Darkmode(options);
        darkmode.showWidget();
        
        }
        window.addEventListener('load', addDarkmodeWidget);
    </script>
  
</html>